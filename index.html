<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Animated Spider Web Lines</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body,
      html {
        height: 100%;
        overflow: hidden;
      }

      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        background-color: #f3f3f3; /* Light background */
      }

      /* Text container styles */
      .text-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        justify-content: space-between; /* Space the boxes equally */
        align-items: stretch; /* Ensure boxes stretch to fill the container */
        z-index: 10; /* Ensure text is above the canvas */
        color: #d6390d;
        font-family: monospace;
        font-size: large; /* Increased font size */
        width: 90%; /* Responsive width */
        max-width: 800px; /* Increased max width for larger screens */
        min-height: 300px; /* Minimum height for better visibility */
      }

      .text-box {
        background-color: rgba(
          255,
          255,
          255,
          0.2
        ); /* Reduced semi-transparent white */
        padding: 20px;
        margin: 10px;
        flex: 1; /* Allow boxes to be of equal size */
        backdrop-filter: blur(2px); /* Reduced blur effect */
        overflow: hidden; /* Prevent overflow */
        min-width: 250px; /* Minimum width for smaller screens */
      }

      h2 {
        margin-bottom: 10px;
        font-size: large; /* Increased heading font size */
      }

      p {
        font-size: medium; /* Increased paragraph font size */
      }

      @media (max-width: 600px) {
        .text-container {
          flex-direction: column; /* Stack boxes on small screens */
          align-items: stretch; /* Stretch to full width */
        }

        .text-box {
          margin: 5px 0; /* Adjust margin for stacked boxes */
          min-width: 100%; /* Ensure boxes take full width */
        }
      }
    </style>
  </head>
  <body>
    <canvas id="webCanvas"></canvas>
    <div class="text-container">
      <div class="text-box">
        <h2>«Թելադրություն» = «թել» + «դրություն»</h2>
        <p>
          Արդյոք մենք ենք ընտրում ինչպես շարժվել, թե՞ մեզ թելադրում են։ Ի՞նչ
          անել։ Գործե՞լ։ Ի՞նչպես գործել այս դրության մեջ։ Հենց ե՞ս։ Ո՞վ եմ ես։
          Գործը արտացոլում է հեղինակների ապրումներն այս հարցերի շուրջ։ Ձայնային
          ինստալյացիան հյուսում է գորգ լաբիրինթի տեսքով: Մեր գորգը կիսատ է, թե՞
          քանդված, որոշեք ինքներդ, բայց այն ունի գործվելու և ամբողջական դառնալու
          կարիք։ Այցելուները հրավիրված են “ազատ” ընտրելու` թելադրվել, թե ոչ,
          ունենալով դիպչելու, ստեղծելու, լսելու, և գործելու հնարավորություն,
          որտեղ ամեն առաջին հայացքից փոքր և անտեսելի քայլ կամ հպում կարող է
          հանգեցնել փոփոխության։
        </p>
      </div>
      <div class="text-box">
        <h2>“Teladrutyun” = “thread[tel]” + “situation[drutyun]”</h2>
        <p>
          Are we choosing how to move, or are we being dictated? What to do?
          Act? How to act in this situation? Just me? Who am I? The work
          reflects the authors’ experiences regarding these questions. The sound
          installation weaves itself in the form of a carpet labyrinth. Is our
          carpet incomplete or broken? Decide for yourself, but it needs to be
          acted upon and made whole. Visitors are invited to “freely” choose
          whether to be dictated to or not, having the opportunity to touch,
          create, listen, and act, where every seemingly small and invisible
          step or touch can lead to change.
        </p>
      </div>
    </div>
    <script>
      const canvas = document.getElementById("webCanvas");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      resizeCanvas();

      // Calculate diagonal of the screen to make sure the lines are longer than it
      const screenDiagonal = Math.sqrt(canvas.width ** 2 + canvas.height ** 2);

      class Line {
        constructor(x, y, length, angle, color, rotationSpeed, speedX, speedY) {
          this.x = x; // Center X
          this.y = y; // Center Y
          this.length = length;
          this.angle = angle;
          this.color = color;
          this.rotationSpeed = rotationSpeed;
          this.speedX = speedX;
          this.speedY = speedY;
        }

        update() {
          // Move line across the screen
          this.x += this.speedX;
          this.y += this.speedY;

          // Bounce off edges
          if (
            this.x <= -this.length / 2 ||
            this.x >= canvas.width + this.length / 2
          )
            this.speedX *= -1;
          if (
            this.y <= -this.length / 2 ||
            this.y >= canvas.height + this.length / 2
          )
            this.speedY *= -1;

          // Rotate the line
          this.angle += this.rotationSpeed;
          this.draw();
        }

        draw() {
          const halfLength = this.length / 2;

          // Calculate start and end points of the line, rotating around its midpoint
          const xStart = this.x - halfLength * Math.cos(this.angle);
          const yStart = this.y - halfLength * Math.sin(this.angle);
          const xEnd = this.x + halfLength * Math.cos(this.angle);
          const yEnd = this.y + halfLength * Math.sin(this.angle);

          ctx.beginPath();
          ctx.moveTo(xStart, yStart);
          ctx.lineTo(xEnd, yEnd);
          ctx.strokeStyle = this.color;
          ctx.lineWidth = 2; // Thicker lines for visibility
          ctx.stroke();
        }
      }

      let linesArray = [];
      const numberOfLines = 20;

      // Function to get random shade of #d6390d
      function getShadeOfColor() {
        const baseColor = [214, 57, 13]; // RGB of #d6390d
        const variation = Math.floor(Math.random() * 60) - 30; // Create slight variations
        return `rgb(${baseColor[0] + variation}, ${baseColor[1] + variation}, ${
          baseColor[2] + variation
        })`;
      }

      // Create lines that are longer than the screen diagonal and move/rotate
      for (let i = 0; i < numberOfLines; i++) {
        let startX = Math.random() * canvas.width; // Random start position
        let startY = Math.random() * canvas.height;
        let length = screenDiagonal * 5.5; // Line length is 5.5 times the diagonal of the screen
        let angle = Math.random() * Math.PI * 2; // Random initial angle
        let rotationSpeed = (Math.random() - 0.5) * 0.005; // Random rotation speed
        let speedX = (Math.random() - 0.5) * 0.5; // Random movement speed in X direction
        let speedY = (Math.random() - 0.5) * 0.5; // Random movement speed in Y direction
        let color = getShadeOfColor();
        linesArray.push(
          new Line(
            startX,
            startY,
            length,
            angle,
            color,
            rotationSpeed,
            speedX,
            speedY
          )
        );
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        linesArray.forEach((line) => line.update());
        requestAnimationFrame(animate);
      }

      animate();

      // Resize canvas if window size changes
      window.addEventListener("resize", () => {
        resizeCanvas();
        linesArray = []; // Reinitialize lines to fit new screen size

        // Recalculate screen diagonal
        const screenDiagonal = Math.sqrt(
          canvas.width ** 2 + canvas.height ** 2
        );

        for (let i = 0; i < numberOfLines; i++) {
          let startX = Math.random() * canvas.width;
          let startY = Math.random() * canvas.height;
          let length = screenDiagonal * 1.5; // Line length is 1.5 times the diagonal of the screen
          let angle = Math.random() * Math.PI * 2;
          let rotationSpeed = (Math.random() - 0.5) * 0.02;
          let speedX = (Math.random() - 0.5) * 2;
          let speedY = (Math.random() - 0.5) * 2;
          let color = getShadeOfColor();
          linesArray.push(
            new Line(
              startX,
              startY,
              length,
              angle,
              color,
              rotationSpeed,
              speedX,
              speedY
            )
          );
        }
      });
    </script>
  </body>
</html>
